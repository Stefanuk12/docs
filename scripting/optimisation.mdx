---
title: Optimising your script
---

Luarmor uses [Luraph™️](https://luraph.com) as the obfuscation provider. So if you're experiencing lags, fps drops, or even crashes, you must use certain `macros` in your script. This documentation will show you everything about the `LPH_NO_VIRTUALIZE` macro

## Why does obfuscation affect performance?

Because [Luraph™️](https://luraph.com) is a VM based obfuscator that generates its own instructions that are interpreted by Luraph, which, in turn, is interpreted by the Lua interpreter. So the number of instruction cycles increases exponentially.

<Accordion title="How obfuscation works">
    Normally, your script gets compiled into a set of Lua instructions. See the example below:

    <Frame caption="How Lua code is compiled to bytecode">
        <img src="/images/optimisation-1.png" alt="a print compiled to Lua bytecode"/>
    </Frame>

    As you can see, your simple "print" statement gets compiled into 4 instructions. Each instruction is a cycle, so it will take **4 cycles to execute your code**.

    When you obfuscate your script, the main goal is to make the original code unreadable. Luraph does this by generating its custom instruction set that can be understood by Luraph VM only. 

    See the example below:

    <Frame caption="How Luraph obfuscates Lua code">
        <img src="/images/optimisation-2.png" alt="part of an obfuscated script and the bytecode representation"/>
    </Frame>

    Notice how your simple print statement turned into 40 instructions, which will take **40 cycles to execute**. Also keep in mind that Luraph does a lot of things to obfuscate the code flow, which will ultimately lead to *even more instructions*.
</Accordion>


Normally, Lua is extremely fast, therefore you **will not notice** any performance impact. But when your code runs **hundreds of times per second**, there will be obvious lags, fps drops, or even freezes during the execution of the instructions above.

A good example would be RenderStepped connections. At this point, everyone knows that you love wrapping your wallhack render function inside this **RenderStepped** event.

<Accordion title="RenderStepped example">
    <Frame caption="Example of a RenderStepped connection">
        <img src="/images/optimisation-3.png" alt="a renderstepped connection"/>
    </Frame>

    This code will be slow when obfuscated. Because the number of instructions generated by Luraph will be more than *2000*. This means Lua will have to run **2000+ instruction cycles** **every** frame. Which will be around **60 * 2000 = 120k** instructions to run every second.

    And there are local functions (e.g. `CalculateParameters`) used in this loop, which automatically means that function will be executed as well, which will lead to *even more and more instructions to run*.
</Accordion>


Here is a second example. A metamethod hook on `__index`:

<Accordion title="__index example">
    <Frame caption="Example of a metamethod hook">
        <img src="/images/optimisation-4.png" alt="a metamethod hook"/>
    </Frame>

    `__index` runs quite often. Example:
    - `game.Workspace`,
    - `game.Players...`
    - etc...

    These will invoke the `__index` function and run the code above. This will be extremely resource intensive and heavy, considering that it is probably called **thousands of times per second**.

    And on top of that, **if you obfuscate this part**, you will end up with **more than a million** instructions to run every second, which will crash your game.
</Accordion>

## How to deal with this problem?

<Warning>
    **Do not** wrap your entire script in LPH_NO_VIRTUALIZE as it defeats the purpose of virtualization (obfuscation). Only use this macro if a function runs more than 30 times per second.
</Warning>

You have to exclude these chunks from obfuscation. You can either use `loadstring()`, or `LPH_NO_VIRTUALIZE`.

It is recommended to use `LPH_NO_VIRTUALIZE` instead of loadstring while excluding chunks from obfuscation, because it is generally harder to view the code when you're using `LPH_NO_VIRTUALIZE`.

## How to use `LPH_NO_VIRTUALIZE`?

`LPH_NO_VIRTUALIZE` takes one constant argument which must be a function, and returns a function that can be called.

<Warning>
    **It is important** to add this on top of your script, so you won't have issues while running the original code.

    ```lua
        getfenv().LPH_NO_VIRTUALIZE = function(f) return f end;
    ```
</Warning>

You will find some examples below on how to properly use `LPH_NO_VIRTUALIZE`:
<AccordionGroup>

    <Accordion title="Good usage">
        ```lua
        RunService.RenderStepped(LPH_NO_VIRTUALIZE(function(s)
            -- regular function body
        end))
        ```
        ```lua
        old = hookmetamethod(game, "__index", LPH_NO_VIRTUALIZE(function(t, k)
            -- regular function body
        end))
        ```
        ```lua
        local generateTracers = LPH_NO_VIRTUALIZE(function(pos, pos2)
            -- function body
        end)
        RunService.Hearbeat:Connect(generateTracers)
        ```
        ```lua
        LPH_NO_VIRTUALIZE(function()
            for i,v in pairs(getgc()) do 
                if type(v) == 'table' then
                    f = v
                end
            end
        end)()
        ```
    </Accordion>
    <Accordion title="Bad usage">
        ```lua
        local function doSomething()
        -- function body
        end
        LPH_NO_VIRTUALIZE(doSomething) -- you can't pass reference arguments
        hookfunction(print, doSomething)
        ```
        ```lua
        LPH_NO_VIRTUALIZE( -- this is a syntax error
            local old old = hookmetamethod(game, "__namecall", function(...) end)
        )
        ```
        ```lua
        LPH_NO_VIRTUALIZE(function()
            -- something
        end) -- This part will not run because you are not calling it at the end.
        -- You should add an extra () at the end in order to call it

        print('done')
        ```
    </Accordion>
</AccordionGroup>

## Where to use `LPH_NO_VIRTUALIZE`?

- `RenderStepped` connections
- `Heartbeat` connections
- `__index` metamethod hooks
- `__namecall` metamethod hooks (optional)
- `while true` loops with no delay
- GC scan loops
- `function`s, if they are called by one of those above